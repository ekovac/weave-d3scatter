<!DOCTYPE html>
<!-- saved from url=(0073)http://examples.oreilly.com/0636920026938/chapter_09/20_axes_dynamic.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>D3: Transitioning points to randomized values, plus rescaled axes!</title>
        <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
        <script type="text/javascript" src="WeaveExternalToolUtils.js"></script>
        <style type="text/css">
            .probe {
                fill: none;
                stroke: black;
                shape-rendering:crispEdges;
            }
            .axis path,
            .axis line {
                fill: none;
                stroke: black;
                shape-rendering: crispEdges;
            }
            
            .axis text {
                font-family: sans-serif;
                font-size: 11px;
            }

        </style>
    <style type="text/css"></style></head>
    <body>
        <script type="text/javascript">

            //Width and height
            var dataset = [];
            var w = 500;
            var h = 300;
            var padding = 30;

            //Create scale functions
            var xScale = d3.scale.linear()
                                 .domain([0, 1])
                                 .range([padding, w - padding * 2]);

            var yScale = d3.scale.linear()
                                 .domain([0, 1])
                                 .range([h - padding, padding]);
            var rScale = d3.scale.linear()
                                 .domain([0, 1])
                                 .range([2, 10]);

            //Define X axis
            var xAxis = d3.svg.axis()
                              .scale(xScale)
                              .orient("bottom")
                              .ticks(5);

            //Define Y axis
            var yAxis = d3.svg.axis()
                              .scale(yScale)
                              .orient("left")
                              .ticks(5);
            var localProbes = {};
            var localSelection = {};
            var localSubset = {};

            //Create SVG element
            var svg = d3.select("body").append("svg");
            //Create element groups for the axes.
            var yAxisElement = svg.append("g").attr("class", "y axis").call(yAxis);

            var xAxisElement = svg.append("g").attr("class", "x axis").call(xAxis);

            update_layout();

            function update_layout()
            {

                //Modify SVG
                svg.attr("width", w).attr("height", h);
                //Create X axis
                xAxisElement.attr("transform", "translate(0," + (h - padding) + ")");
                
                //Create Y axis
                yAxisElement.attr("transform", "translate(" + padding + ",0)");

                // Update xScale and yScale according to changes in padding
                xScale.range([padding, w - padding * 2]);
                yScale.range([h - padding, padding]);

                plot();
            }

            function get_windowsize()
            {
                /* Ganked from http://stackoverflow.com/questions/3437786/how-to-get-web-page-size-browser-window-size-screen-size-in-a-cross-browser-wa */
                var w = window,
                    d = document,
                    e = d.documentElement,
                    g = d.getElementsByTagName('body')[0],
                    x = w.innerWidth || e.clientWidth || g.clientWidth,
                    y = w.innerHeight|| e.clientHeight|| g.clientHeight;
                return {x: x, y: y};
            }




            function keyfunc(data)
            {
                return data.key;
            }

            function weave_to_d3(raw_data, column_names)
            {
                raw_data_len = raw_data[0].length;

                var new_dataset = [];
                for (var raw_idx = 0; raw_idx < raw_data_len; raw_idx++)
                {
                    var new_datum = {}
                    new_datum.key = WeaveExternalToolUtils.qkey_to_string(raw_data[0][raw_idx]);
                    for (var col_idx = 0; col_idx < column_names.length; col_idx++)
                    {
                        /* TODO: Smart conversion to numeric. */
                        new_datum[column_names[col_idx]] = raw_data[col_idx+1][raw_idx];
                    }
                    if (WeaveExternalToolUtils.qkey_in_keyset(new_datum.key, toolInterface.subset_keyset))
                    {
                        new_dataset.push(new_datum);
                    }
                }
                return new_dataset;
            }

            function data_updated()
            {
                column_names = ['x', 'y', 'size', 'color'];
                var raw_data = WeaveExternalToolUtils.retrieve_columns(toolInterface.path, column_names);
                
                dataset = weave_to_d3(raw_data, column_names);

                plot();

                return;
            }
            function in_set(d,s)
            {
                if (d == undefined) return null;
                if (s[d.key] == undefined) return null;
                return d;
            }
            function set_negate(a,b) {
                var result = {};
                for (var k in a)
                {
                    if (b[k] == undefined)
                        result[k] = a[k];
                }
                return result;
            }
            function in_probeset(d,i,a) {return in_set(d, localProbes);}
            function in_selectionset(d,i,a) {return in_set(d, localSelection);}
            function in_subset(d,i,a) {
                if (Object.keys(localSubset).length == 0) return d; // Always return the object if we have an empty subset. 
                return in_set(d, localSubset);
            }
            var debug_tmp;
            function plot()
            {
                var working_dataset = dataset;
                var probe_dataset = dataset.filter(in_probeset);

                //Update scale domains.
                if (xScaleFunc == d3.scale.log) min = 1; else min = 0;              
                xScale.domain([min, d3.max(working_dataset, function(d) { return d.x; })]);

                if (yScaleFunc == d3.scale.log) min = 1; else min = 0;
                yScale.domain([min, d3.max(working_dataset, function(d) { return d.y; })]);


                rScale.domain([min, d3.max(working_dataset, function(d) { return d.size; })]);

                // Add any new records. 
                svg.selectAll("circle")
                    .data(working_dataset, keyfunc)
                    .enter()
                    .append("circle")
                    .attr("cx", function(d) {
                        return xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return yScale(d.y);
                    })
                    .attr("opacity", 1)
                    .attr("r", function(d) { 
                        if (d.size != NaN && d.size != null) 
                            return rScale(d.size);
                        else
                            return rScale(0);
                    })
                    .on("mouseover", probed)
                    .on("mouseout", unprobed);

                //Update all circles
                svg.selectAll("circle")
                   .data(working_dataset, keyfunc)
                   .transition()
                   .duration(250)      
                   .attr("cx", function(d) {
                        return xScale(d.x);
                   })
                   .attr("cy", function(d) {
                        return yScale(d.y);
                   })
                   .attr("r", function(d) { 
                        if (d.size != NaN && d.size != null) 
                            return rScale(d.size);
                        else
                            return rScale(0);
                    });
                // Remove missing records.
                svg.selectAll("circle")
                    .data(dataset, keyfunc)
                    .exit()
                    .transition()
                    .duration(250)
                    .attr("opacity", 0)
                    .remove();
                // Enter probe records. 
                svg.selectAll("circle.probe")
                    .data(probe_dataset, keyfunc)
                    .enter()
                    .append("circle")
                    .attr("class", "probe")
                    .attr("cx", function(d) {
                        return xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return yScale(d.y);
                    })
                    .attr("opacity", 0.5)
                    .attr("fill", "none")
                    .attr("r", function(d) { 
                        if (d.size != NaN && d.size != null) 
                            return rScale(d.size)*1.2;
                        else
                            return rScale(0)*1.2;
                    })

                // Remove probe
                svg.selectAll("circle.probe")
                    .data(probe_dataset, keyfunc)
                    .exit()
                    .transition()
                    .duration(250)
                    .attr("opacity", 0)
                    .remove();

                //Update X axis
                svg.select(".x.axis")
                    .transition()
                    .duration(250)
                    .call(xAxis);
                
                //Update Y axis
                svg.select(".y.axis")
                    .transition()
                    .duration(250)
                    .call(yAxis);
            };



            var toolInterface;
            var SCALE_TYPES = {
                "Linear": d3.scale.linear,
                "Logarithmic": d3.scale.log
            };
            var xScaleFunc = d3.scale.linear;
            var yScaleFunc = d3.scale.linear;
            function yscale_changed()
            {
                console.log("y scale changed")
                var scale_type = this.getState();
                yScaleFunc = SCALE_TYPES[scale_type];
                if (yScaleFunc)
                {
                    yScale = yScaleFunc()
                }
                else
                {
                    console.log("yScaleType Doesn't match anything, setting back to Linear");
                    toolInterface.properties.xscale_type.state("Linear");
                }
                yAxis.scale(yScale);
                update_layout();
            }
            function xscale_changed()
            {
                console.log("x scale changed")
                var scale_type = this.getState();
                xScaleFunc = SCALE_TYPES[scale_type];
                if (xScaleFunc)
                {
                    xScale = xScaleFunc()
                }
                else
                {
                    console.log("xScaleType Doesn't match anything, setting back to Linear");
                    toolInterface.properties.xscale_type.state("Linear");
                }
                xAxis.scale(xScale);
                update_layout();
            }
            function size_changed( ) 
            {
                var tmp_size = toolInterface.properties.base_size.getState();
                var tmp_max_size = toolInterface.properties.max_size.getState();
                console.log("size_changed called");
                if (isNaN(tmp_size))
                {
                    console.log("base_size invalid, setting to default");
                    toolInterface.properties.base_size.state(5);
                    tmp_size = 5;
                }
                if (isNaN(tmp_max_size))
                {
                    console.log("max_size invalid, setting to default");
                    toolInterface.properties.max_size.state(tmp_size);
                    tmp_max_size = 5;
                }
                rScale.range([tmp_size, tmp_max_size]);
                plot();
            }
            function selection_changed()
            {

            }
            function probe_changed()
            {
                var remoteProbes = toolInterface.probe_keyset.getValue("this.keys");
                var remoteProbeState = toolInterface.probe_keyset.getState();
                localProbes = {};

                for (key in remoteProbes)
                {
                    localProbes[WeaveExternalToolUtils.qkey_to_string(remoteProbes[key])] = true;
                }

                plot();
            }

            function update_probes()
            {
                nativeKeys = new opener.Array;
                for (key in localProbes)
                {
                    nativeKeys.push(WeaveExternalToolUtils.string_to_qkey(key));
                }
                toolInterface.probe_keyset.vars({keys: nativeKeys}).exec('replaceKeys(keys)');
            }
            function probed(d)
            {
                //console.log( "Probed: " + JSON.stringify(d.key) );
                localProbes = {};
                localProbes[d.key] = true;
                update_probes();
            }

            function unprobed(d)
            {
                //console.log( "Unprobed: " + JSON.stringify(d.key) );
                localProbes = {};
                update_probes();
            }

            function selection_changed()
            {
            }
            function subset_changed()
            {
                data_updated();
            }
            function layout_changed()
            {
                var tmp_w = toolInterface.properties.requested_width.getState();
                var tmp_h = toolInterface.properties.requested_height.getState();

                var valid = false;
                if (tmp_h)
                {
                    h = tmp_h;
                    valid = true;
                }
                if (tmp_w)
                {
                    w = tmp_w;
                    valid = true;
                }

                if (valid)
                {
                    update_layout();
                }
            }
            function weave_setup() 
            {
                var properties_template = {
                    DynamicColumn: {'x': data_updated,
                                    'y': data_updated,
                                    'color': data_updated,
                                    'size': data_updated
                                    },

                    LinkableString: {'xscale_type': xscale_changed,
                                    'yscale_type': yscale_changed
                                    },

                    LinkableNumber: {'base_size':size_changed,
                                     'max_size':size_changed,
                                     'requested_width':layout_changed,
                                     'requested_height':layout_changed
                                    }
                };
                
                toolInterface = {};
                WeaveExternalToolUtils.setup_properties(toolInterface, properties_template);
                toolInterface.probe_keyset.addCallback(probe_changed);
                toolInterface.select_keyset.addCallback(selection_changed);
                toolInterface.subset_keyset.addCallback(subset_changed);
            };

            weave_setup();
            </script>   
</body></html>
