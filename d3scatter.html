<!DOCTYPE html>
<!-- saved from url=(0073)http://examples.oreilly.com/0636920026938/chapter_09/20_axes_dynamic.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta charset="utf-8">
		<title>D3: Transitioning points to randomized values, plus rescaled axes!</title>
		<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
		<style type="text/css">
			
			.axis path,
			.axis line {
				fill: none;
				stroke: black;
				shape-rendering: crispEdges;
			}
			
			.axis text {
				font-family: sans-serif;
				font-size: 11px;
			}

		</style>
	<style type="text/css"></style></head>
	<body>
	
		<p>Click on this text to update the chart with new data values as many times as you like!</p>
	
		<script type="text/javascript">

			//Width and height
			var dataset = [];
			var w = 500;
			var h = 300;
			var padding = 30;

			//Create scale functions
			var xScale = d3.scale.linear()
								 .domain([0, 1])
								 .range([padding, w - padding * 2]);

			var yScale = d3.scale.linear()
								 .domain([0, 1])
								 .range([h - padding, padding]);

			//Define X axis
			var xAxis = d3.svg.axis()
							  .scale(xScale)
							  .orient("bottom")
							  .ticks(5);

			//Define Y axis
			var yAxis = d3.svg.axis()
							  .scale(yScale)
							  .orient("left")
							  .ticks(5);

			//Create SVG element
			var svg = d3.select("body")
						.append("svg")
						.attr("width", w)
						.attr("height", h);
			
			//Create X axis
			svg.append("g")
				.attr("class", "x axis")
				.attr("transform", "translate(0," + (h - padding) + ")")
				.call(xAxis);
			
			//Create Y axis
			svg.append("g")
				.attr("class", "y axis")
				.attr("transform", "translate(" + padding + ",0)")
				.call(yAxis);

                        

			function weave_retrieve_columns(column_parent, column_names)
            {
                var data = column_parent.libs('weave.utils.ColumnUtils').naturalize()
                    .vars({names: column_names})
                    .getValue("ColumnUtils.joinColumns(names.map(function(name){return getObject(name); }), null, true)");
                return data;
            }

            function qkey_to_string(raw_qkey)
            {
            	return JSON.stringify([raw_qkey.keyType, raw_qkey.localName]);
            }

            function keyfunc(d)
			{
				return d.key;
			}
			function weave_to_d3(raw_data, column_names)
			{
				raw_data_len = raw_data[0].length;

				var new_dataset = [];
				for (var raw_idx = 0; raw_idx < raw_data_len; raw_idx++)
				{
					var new_datum = {}
					new_datum.key = qkey_to_string(raw_data[0][raw_idx]);
					for (var col_idx = 0; col_idx < column_names.length; col_idx++)
					{
						/* TODO: Smart conversion to numeric. */
						new_datum[column_names[col_idx]] = raw_data[col_idx+1][raw_idx];
					}
					new_dataset.push(new_datum);
				}
				return new_dataset;
			}
			function data_updated()
			{
				column_names = ['x', 'y', 'size', 'color'];
				
				var raw_data = weave_retrieve_columns(toolInterface.path, column_names);
				
				dataset = weave_to_d3(raw_data, column_names);

				plot();

				return;
			}
			function plot()
			{

				//Update scale domains.
				xScale.domain([0, d3.max(dataset, function(d) { return d.x; })]);
				yScale.domain([0, d3.max(dataset, function(d) { return d.y; })]);
				// Add any new records. 
				svg.selectAll("circle")
		   			.data(dataset, keyfunc)
		   			.enter()
		   			.append("circle")
		   			.attr("cx", function(d) {
		   				return xScale(d.x);
		   			})
		   			.attr("cy", function(d) {
		  				return yScale(d.y);
		   			})
		   			.attr("r", 2);

				//Update all circles
				svg.selectAll("circle")
				   .data(dataset, keyfunc)
				   .transition()
				   .duration(1000)		
				   .attr("cx", function(d) {
				   		return xScale(d.x);
				   })
				   .attr("cy", function(d) {
				   		return yScale(d.y);
				   });

				//Update X axis
				svg.select(".x.axis")
			    	.transition()
			    	.duration(1000)
					.call(xAxis);
				
				//Update Y axis
				svg.select(".y.axis")
			    	.transition()
			    	.duration(1000)
					.call(yAxis);
			};

            function weave_setup_properties(baseName, properties_template)
            {
            	var weaveInterface = {};
                weaveInterface.properties = {};

                /* Shared keysets used for cross-tool integration */
                weaveInterface.probe_keyset = weave.path("defaultProbeKeySet");
                weaveInterface.select_keyset = weave.path("defaultSelectionKeySet");
                weaveInterface.subset_keyset = weave.path("defaultSubsetKeyFilter");

                
                /* TODO: Test if the tool already exists and set a variable indicating we're restoring from session state */
                /* Request the base tool object */
                weaveInterface.path = weave.path([baseName]).request([], "LinkableHashMap");

                /* Dynamically create the relevant properties from the template, and bind the specified callbacks */
                for (var variableType in properties_template)
                {
                    var variables = {};
                    for (var variableName in properties_template[variableType])
                    {
                        var localPath = weave.path([baseName, variableName]).request([], variableType);
                        variables[variableName] = localPath;

                        localPath.addCallback(properties_template[variableType][variableName]);
                    }
                    weaveInterface.properties[variableType] = variables;
                }
                return weaveInterface;
            };

            var toolInterface;

            function scale_changed(){};
            function size_changed(){};
            function probe_changed(){};
            function selection_changed(){};
            function subset_changed(){};

			function weave_setup() 
            {
            	if (window.weave === undefined) window.weave = opener.weave;

                var properties_template = {
                    DynamicColumn: {'x': data_updated,
                                    'y': data_updated,
                                    'color': data_updated,
                                    'size': data_updated
                    },

                    LinkableString: {'scaleType': scale_changed },

                    LinkableNumber: {'default_size':size_changed,
                    				 'max_size':size_changed,
                    				 'min_size':size_changed
                    				}
                };
                if (name == "") name = "WeaveD3Scatter";
               	
               	toolInterface = weave_setup_properties(name, properties_template);
               	toolInterface.probe_keyset.addCallback(probe_changed);
                toolInterface.select_keyset.addCallback(selection_changed);
                toolInterface.subset_keyset.addCallback(subset_changed);

            };

			//On click, update with new data			
			d3.select("p").on("click", data_updated);
			// Initial update. 
			
			weave_setup();

            </script>	
</body></html>
