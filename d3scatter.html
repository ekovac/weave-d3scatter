<!DOCTYPE html>
<!-- saved from url=(0073)http://examples.oreilly.com/0636920026938/chapter_09/20_axes_dynamic.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>D3: Transitioning points to randomized values, plus rescaled axes!</title>
        <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
        <style type="text/css">
            .probe {
                fill: none;
                stroke: black;
                shape-rendering:crispEdges;
            }
            .axis path,
            .axis line {
                fill: none;
                stroke: black;
                shape-rendering: crispEdges;
            }
            
            .axis text {
                font-family: sans-serif;
                font-size: 11px;
            }

        </style>
    <style type="text/css"></style></head>
    <body>
        <script type="text/javascript">

            //Width and height
            var dataset = [];
            var w = 500;
            var h = 300;
            var padding = 30;

            //Create scale functions
            var xScale = d3.scale.linear()
                                 .domain([0, 1])
                                 .range([padding, w - padding * 2]);

            var yScale = d3.scale.linear()
                                 .domain([0, 1])
                                 .range([h - padding, padding]);
            var rScale = d3.scale.linear()
                                 .domain([0, 1])
                                 .range([2, 10]);

            //Define X axis
            var xAxis = d3.svg.axis()
                              .scale(xScale)
                              .orient("bottom")
                              .ticks(5);

            //Define Y axis
            var yAxis = d3.svg.axis()
                              .scale(yScale)
                              .orient("left")
                              .ticks(5);
            var localProbes = {};
            var localSelection = {};
            var localSubset = {};

            //Create SVG element
            var svg = d3.select("body").append("svg");
            //Create element groups for the axes.
            var yAxisElement = svg.append("g").attr("class", "y axis").call(yAxis);

            var xAxisElement = svg.append("g").attr("class", "x axis").call(xAxis);

            update_layout();

            function update_layout()
            {

                //Modify SVG
                svg.attr("width", w).attr("height", h);
                //Create X axis
                xAxisElement.attr("transform", "translate(0," + (h - padding) + ")");
                
                //Create Y axis
                yAxisElement.attr("transform", "translate(" + padding + ",0)");

                // Update xScale and yScale according to changes in padding
                xScale.range([padding, w - padding * 2]);
                yScale.range([h - padding, padding]);

                plot();
            }

            function get_windowsize()
            {
                /* Ganked from http://stackoverflow.com/questions/3437786/how-to-get-web-page-size-browser-window-size-screen-size-in-a-cross-browser-wa */
                var w = window,
                    d = document,
                    e = d.documentElement,
                    g = d.getElementsByTagName('body')[0],
                    x = w.innerWidth || e.clientWidth || g.clientWidth,
                    y = w.innerHeight|| e.clientHeight|| g.clientHeight;
                return {x: x, y: y};
            }

            function weave_retrieve_columns(column_parent, column_names)
            {
                var data = column_parent.libs('weave.utils.ColumnUtils').naturalize()
                    .vars({names: column_names})
                    .getValue("ColumnUtils.joinColumns(names.map(function(name){return getObject(name); }), null, true)");
                return data;
            }
            function weave_in_keyset(key, keyset_path)
            {
                var qkey = string_to_qkey(key);
                var result = keyset_path.naturalize()
                            .vars({localName: qkey.localName, keyType: qkey.keyType})
                            .libs('weave.api.WeaveAPI')
                            .getValue("containsKey(WeaveAPI.QKeyManager.getQKey(keyType, localName))");
                return result;
            }
            function qkey_to_string(raw_qkey)
            {
                return JSON.stringify([raw_qkey.keyType, raw_qkey.localName]);
            }
            function string_to_qkey(jsonstring)
            {
                var raw_arr = JSON.parse(jsonstring);
                return {keyType: raw_arr[0], localName: raw_arr[1]};
            }

            function keyfunc(d)
            {
                return d.key;
            }

            function weave_to_d3(raw_data, column_names)
            {
                raw_data_len = raw_data[0].length;

                var new_dataset = [];
                for (var raw_idx = 0; raw_idx < raw_data_len; raw_idx++)
                {
                    var new_datum = {}
                    new_datum.key = qkey_to_string(raw_data[0][raw_idx]);
                    for (var col_idx = 0; col_idx < column_names.length; col_idx++)
                    {
                        /* TODO: Smart conversion to numeric. */
                        new_datum[column_names[col_idx]] = raw_data[col_idx+1][raw_idx];
                    }
                    if (weave_in_keyset(new_datum.key, toolInterface.subset_keyset))
                    {
                        new_dataset.push(new_datum);
                    }
                }
                return new_dataset;
            }

            function data_updated()
            {
                column_names = ['x', 'y', 'size', 'color'];
                var parent = weave.path(this.getPath().slice(0,-1));
                var raw_data = weave_retrieve_columns(parent, column_names);
                
                dataset = weave_to_d3(raw_data, column_names);

                plot();

                return;
            }
            function in_set(d,s)
            {
                if (s[d.key] === undefined) return null;
                return d;
            }

            function in_probeset(d) {return in_set(d, localProbes);}
            function in_selectionset(d) {return in_set(d, localSelection);}
            function in_subset(d,i,a) {
                if (Object.keys(localSubset).length == 0) return d; // Always return the object if we have an empty subset. 
                return in_set(d, localSubset);
            }
            var debug_tmp;
            function plot()
            {
                var working_dataset = dataset;

                //Update scale domains.
                if (xScaleFunc == d3.scale.log) min = 1; else min = 0;              
                xScale.domain([min, d3.max(working_dataset, function(d) { return d.x; })]);

                if (yScaleFunc == d3.scale.log) min = 1; else min = 0;
                yScale.domain([min, d3.max(working_dataset, function(d) { return d.y; })]);


                rScale.domain([min, d3.max(working_dataset, function(d) { return d.size; })]);

                // Add any new records. 
                svg.selectAll("circle")
                    .data(working_dataset, keyfunc)
                    .enter()
                    .append("circle")
                    .attr("cx", function(d) {
                        return xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return yScale(d.y);
                    })
                    .attr("r", function(d) { 
                        if (d.size != NaN && d.size != null) 
                            return rScale(d.size);
                        else
                            return rScale(0);
                    })
                    .on("mouseover", probed)
                    .on("mouseout", unprobed);

                //Update all circles
                svg.selectAll("circle")
                   .data(working_dataset, keyfunc)
                   .transition()
                   .duration(1000)      
                   .attr("cx", function(d) {
                        return xScale(d.x);
                   })
                   .attr("cy", function(d) {
                        return yScale(d.y);
                   })
                   .attr("r", function(d) { 
                        if (d.size != NaN && d.size != null) 
                            return rScale(d.size);
                        else
                            return rScale(0);
                    });
                // Remove missing records.
                svg.selectAll("circle")
                    .data(working_dataset, keyfunc)
                    .exit()
                    .transition()
                    .duration(1000)
                    .attr("alpha", 0)
                    .remove();

                //Update X axis
                svg.select(".x.axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                
                //Update Y axis
                svg.select(".y.axis")
                    .transition()
                    .duration(1000)
                    .call(yAxis);
            };

            function weave_setup_properties(root, properties_template)
            {
                toolInterface = {};
                toolInterface.properties = {};

                /* Shared keysets used for cross-tool integration */
                toolInterface.probe_keyset = weave.path("defaultProbeKeySet");
                toolInterface.select_keyset = weave.path("defaultSelectionKeySet");
                toolInterface.subset_keyset = weave.path("defaultSubsetKeyFilter");

                
                /* TODO: Test if the tool already exists and set a variable indicating we're restoring from session state */
                /* Request the base tool object */
                toolInterface.path = weave.path(root).request([], "ExternalTool");

                /* Dynamically create the relevant properties from the template, and bind the specified callbacks */
                for (var variableType in properties_template)
                {
                    for (var variableName in properties_template[variableType])
                    {
                        var localPathArray = root.concat([variableName]);

                        var localPath = weave.path(localPathArray).request([], variableType);

                        toolInterface.properties[variableName] = localPath;
                    }
                }
                /* Loop over it again to add the callbacks; we can't do this in the same loop that creates it or else some things won't be ready for the first run of the callbacks. */
                for (var variableType in properties_template)
                {
                    for (var variableName in properties_template[variableType])
                    {
                        toolInterface.properties[variableName].addCallback(properties_template[variableType][variableName], true);
                    }
                }
            };

            var toolInterface;
            var SCALE_TYPES = {
                "Linear": d3.scale.linear,
                "Logarithmic": d3.scale.log
            };
            var xScaleFunc = d3.scale.linear;
            var yScaleFunc = d3.scale.linear;
            function yscale_changed()
            {
                console.log("y scale changed")
                var scale_type = this.getState();
                yScaleFunc = SCALE_TYPES[scale_type];
                if (yScaleFunc)
                {
                    yScale = yScaleFunc()
                }
                else
                {
                    console.log("yScaleType Doesn't match anything, setting back to Linear");
                    toolInterface.properties.xscale_type.state("Linear");
                }
                yAxis.scale(yScale);
                update_layout();
            }
            function xscale_changed()
            {
                console.log("x scale changed")
                var scale_type = this.getState();
                xScaleFunc = SCALE_TYPES[scale_type];
                if (xScaleFunc)
                {
                    xScale = xScaleFunc()
                }
                else
                {
                    console.log("xScaleType Doesn't match anything, setting back to Linear");
                    toolInterface.properties.xscale_type.state("Linear");
                }
                xAxis.scale(xScale);
                update_layout();
            }
            function size_changed( ) 
            {
                var tmp_size = toolInterface.properties.base_size.getState();
                var tmp_max_size = toolInterface.properties.max_size.getState();
                console.log("size_changed called");
                if (isNaN(tmp_size))
                {
                    console.log("base_size invalid, setting to default");
                    toolInterface.properties.base_size.state(5);
                    tmp_size = 5;
                }
                if (isNaN(tmp_max_size))
                {
                    console.log("max_size invalid, setting to default");
                    toolInterface.properties.max_size.state(tmp_size);
                    tmp_max_size = 5;
                }
                rScale.range([tmp_size, tmp_max_size]);
                plot();
            }

            function probe_changed()
            {

            }

            function update_probes()
            {
                nativeKeys = new opener.Array;
                for (key in localProbes)
                {
                    nativeKeys.push(string_to_qkey(key));
                }
                weave.evaluateExpression(toolInterface.probe_keyset.getPath(), 
                                         'replaceKeys(keys)',
                                         {keys: nativeKeys});
            }
            function probed(d)
            {
                //console.log( "Probed: " + JSON.stringify(d.key) );
                localProbes[d.key] = true;
                update_probes();
            }

            function unprobed(d)
            {
                //console.log( "Unprobed: " + JSON.stringify(d.key) );
                delete localProbes[d.key];
                update_probes();
            }

            function selection_changed()
            {
            }
            function subset_changed()
            {
                data_updated();
            }
            function layout_changed()
            {
                var tmp_w = toolInterface.properties.requested_width.getState();
                var tmp_h = toolInterface.properties.requested_height.getState();

                var valid = false;
                if (tmp_h)
                {
                    h = tmp_h;
                    valid = true;
                }
                if (tmp_w)
                {
                    w = tmp_w;
                    valid = true;
                }

                if (valid)
                {
                    update_layout();
                }
            }
            function weave_setup() 
            {
                var properties_template = {
                    DynamicColumn: {'x': data_updated,
                                    'y': data_updated,
                                    'color': data_updated,
                                    'size': data_updated
                                    },

                    LinkableString: {'xscale_type': xscale_changed,
                                    'yscale_type': yscale_changed
                                    },

                    LinkableNumber: {'base_size':size_changed,
                                     'max_size':size_changed,
                                     'requested_width':layout_changed,
                                     'requested_height':layout_changed
                                    }
                };
                
                weave_setup_properties(toolPath, properties_template);
                toolInterface.probe_keyset.addCallback(probe_changed);
                toolInterface.select_keyset.addCallback(selection_changed);
                toolInterface.subset_keyset.addCallback(subset_changed);
            };

            weave_setup();

            </script>   
</body></html>
